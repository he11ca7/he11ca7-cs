# Переменные
Общая форма объявления переменной `var` состоит из имени, типа и выражения инициализации:
```go
var name type = expression
```

Возможно пропустить либо `type`, либо `= expression`.
Если пропущен `type`, тип определяется из выражения инициализации.
Если пропущено `= expression` устанавливается нулевое значение *(zero-value)* для данного `type`:
- `false` для булевого типа
- `0` для числовых типов
- `“”` для строкового типа
- `nil` для интерфейсов и ссылочных типов (указателей, срезов, отображений, каналов, функций)

Нулевое значение составного типа складывается из нулевых значений его составляющих.

Возможно перечисление нескольких переменных через запятую, а так же объединение объявлений *(factored declaration)*:
```go
var i, j, k int
var b, f, s = true, 2.3, "four"
var (
	flag, fl   bool       = false
	x          complex128 = -5 + 12i
)
```

Внутри функций возможна короткая форма `:=` объявления с инициализацией. Тип выводится *(type deduction, type inference)* неявно *(implicit)* из выражения инициализации.

Короткая форма объявления с инициализацией с перечислением не объявляет повторно переменные, уже объявленные в том же лексическом блоке, а действует для них как присвоение. В короткой форме объявления с инициализацией с перечислением хотя бы одна переменная должна быть объявлена:
```go
in, err := os.Open(infile1)     // Объявлены in и err
out, err := os.Create(outfile)  // Объявлена out, присвоена err
in, err := os.Open(infile2)     // Ошибка компиляции, нет ни одного объявления
```
# Переменные-указатели
Переменные-указатели хранят адреса переменных и объявляются добавлением `*` к типу.
Оператор амперсанд `&` позволяет получить адрес *(reference)* переменной.
Оператор звёздочка `*` позволяет получить переменную из адреса - разыменовать указатель *(dereference)*. Разыменование указателя `nil` вызывает `panic`.

```go
x := 1
var p *int = &x // указатель p типа *int указывает на x  
*p = 2          // эквивалент x = 2
```

>[!question]
>Как работает `new(T)`?
# Константы
`const` объявляет константу.
`const` могут быть только примитивные типы: булевый, числовые и строковый.
Возможно перечисление нескольких констант через запятую, а так же объединение объявлений *(factored declaration)*:
```go
const π = 3.1416
const (
	A, B int64   = -3, 5
	Y    float32 = 2.718
)
```
Константы вычисляются на этапе компиляции *(compile time)*.
Взятие адреса (`&`) недоступно для констант.
## iota
Предопределённая константа `iota` используется для генерации констант и инкрементируется в каждом следующем элементе данного объединения объявлений, начиная с 0:
```go
const (
	k = 3 // iota == 0

	m float32 = iota + .5 // m float32 = 1 + .5
	n                     // n float32 = 2 + .5

	p = 9             // iota == 3
	q = iota * 2      // q = 4 * 2
	_                 // _ = 5 * 2
	r                 // r = 6 * 2
	s, t = iota, iota // s, t = 7, 7
	u, v              // u, v = 8, 8
	_, w              // _, w = 9, 9
)
const x = iota // x = 0
const (
	Readable = 1 << iota // == 1
	Writable             // == 2
	Executable           // == 4
)
```
# Типы
Общая форма объявления типа *(type declaration)* `type` состоит из имени и подлежащего типа:
```go
type name underlying_type
```

Возможно объединение объявлений *(factored declaration)*.

Тип и его подлежащий тип являются принципиально разными типами. Для типов с одним и тем же подлежащим типом недоступны арифметические и логические операции без явного *(explicit)* приведения типов.
```go
type Celsius float64  
type Fahrenheit float64  
  
func main()  {  
    var cel Celsius = 10
    var fah Fahrenheit = Fahrenheit(cel*9/5 + 32)
}
```

Приведение одного типа к другому не меняет значение переменной в памяти и его представление; делает изменение смысла (типа) явным.

```go
type (
	MyInt int
	Age   int
	Text  string
)

type IntPtr *int
type Book struct{author, title string; pages int}
type Convert func(in0 int, in1 bool)(out0 int, out1 string)
type StringArray [5]string
type StringSlice []string

func f() {
	type PersonAge map[string]int
	type MessageQueue chan string
	type Reader interface{Read([]byte) int}
}
```

См. [[002 struct|struct]].
# Псевдоним типа
Общая форма объявления псевдонима (алиаса) типа *(type alias declaration)* `type` состоит из имени и подлежащего типа:
```go
type name = underlying_type
```

Возможно объединение объявлений *(factored declaration*).

В отличие от типов *(factored declaration)*, алиас типа не создаёт отдельный тип, а лишь вводит его альтернативное название.