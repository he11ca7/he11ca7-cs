# Канал

Для Go справедлив постулат "Не общайтесь разделением памяти. Разделяйте память через общение", - вызовы не делят память, а безопасно передают данные через каналы.

Канал работает в семантике FIFO. Операции над каналами являются потокобезопасными для горутин. Канал является примитивом синхронизации в контексте блокировки горутин в момент чтения/записи.

Канал типизирован. Литерал канала:
- `chan T` - двунаправленный канал
- `chan<- T` - однонаправленный канал только для записи
- `<-chan T` - однонаправленный канал только для чтения
... где:
- `T` - произвольный тип для значений в канале

`make()` инициализирует канал заданного типа `T` и ёмкости `N`: `make(chan T, N)`. Нулевым значением (неинициализированного) канала является `nil`.

Канал с нулевой ёмкостью `N` называется небуферизированным.
Канал с ненулевой ёмкостью `N` называется буферизированным.

`cap()` возвращает ёмкость канала, а `len()` позволяет получить текущее число элементов в очереди.

Запись в канал осуществляется оператором `channel <- value`. Канал не должен быть однонаправленным только для чтения.

Чтение из канала осуществляется оператором `value = <-channel`. Канал не должен быть однонаправленным только для записи. Доступна форма чтения с признаком того, был ли прочтённый результат записан до закрытия канала: `value, ok = <-channel`. Если `!ok`, значит:
1. Канал закрыт
2. Кольцевая очередь данных `buf` пуста
3. В `value` нулевое значение типа `T`

Вызов `close(channel)` закрывает канал. Канал не должен быть однонаправленным только для чтения.

С момента закрытия канала:
- Горутины из очереди на чтение получают zero-value и разблокируются
- Горутины из очереди на запись паникуют

Граничные кейсы операций над каналами:
- **(A)** Запись и чтение с nil-каналом навсегда блокирует горутину *(поскольку никогда не появится горутина, способная соответственно записать/прочитать с данным каналом)*
- **(B)** Запись в закрытый (non-nil) канал вызывает панику
- **(C)** Чтение из закрытого (non-nil) канала всегда неблокируемо возвращает результат
- **(D)** Закрытие закрытого или nil-канала вызывает панику горутины *(поскольку данные операции не имеют осмысленной причины)*

| Операция | nil-канал             | Закрытый (non-nil) канал | Не закрытый (non-nil) канал |
| -------- | --------------------- | ------------------------ | --------------------------- |
| Закрытие | **(D)** panic         | **(D)** panic            | succeed to close            |
| Запись   | **(A)** block forever | **(B)** panic            | block or succeed to send    |
| Чтение   | **(A)** block forever | **(C)** never block      | block or succeed to receive |
# Внутреннее устройство

1. `lock mutex` - мьютекс для защиты полей
2. `closed uint32` - флаг закрытия канала; тип не `bool`, потому что нет атомика такого типа
3. `elemsize uint16` - размер `elemtype` в байтах
4. `elemtype uint32` - дескриптор типа `T

5. `recvq *list` - **очередь горутин на чтение**
6. `sendq *list` - **очередь горутин на запись**

`recvq` и `sendq` хранят структуры с полями `G` - дескриптор горутины и `elem` - элемент на запись, либо ссылка на область памяти на чтение.

8. `buf *buffer` - **кольцевая очередь данных** буферизованного канала, представляет собой последовательный блок памяти
9. `dataqsiz uint` - ёмкость кольцевой очереди
10. `qcount uint` - **количество элементов** в кольцевой очереди
11. `recvx uint` - **индекс элемента на чтение** в кольцевой очереди; 0 по-умолчанию
12. `sendx uint` - **индекс элемента на запись** в кольцевой очереди; 0 по-умолчанию

`recvx` и `sendx` инкрементируется после успешного чтения/записи из кольцевой очереди соответственно и обнуляются при достижении ёмкости кольцевой очереди `dataqsiz`.

Далее `S` - горутина-отправитель, `R` - горутина-получатель.
## Запись в канал
1. Есть горутина в очереди на чтение `recvq`...
    (~ кольцевая очередь данных `buf` пуста)
    ... для первой горутины `R` из `recvq`:
    1. Вызов `sendDirect()` -> прямое перемещение данных из стека `S` в `R`
    2. Вызов `goready()` на `R` -> планировщик переводит `R` в состояние `runnable`
    *(оптимизация: пропускается этап записи в `buf`, а `R` не нужно отслеживать появление данных и лочить канал)*
1. Нет горутин в очереди на чтение `recvq`...
	1. Есть место в кольцевой очереди данных `buf`...
        (~ очередь горутин на запись `sendq` пуста)
        ... запись в ячейку `buf[sendx]`
	2. Нет места в кольцевой очереди данных `buf`...
	    ... вызов `gopark()` на `S` -> планировщик переводит `S` в состояние `waiting`
	    `S` + записываемый элемент перемещаются в очередь `sendq`

## Чтение из канала
1. Есть данные в кольцевой очереди `buf`...
    (~ очередь горутин на чтение `recvq` пуста)
    ... чтение из ячейки `buf[recvx]`
	Есть горутина в очереди на запись `sendq`...
    ... для первой горутины `S` из `sendq`:
    1. Перенос данных `S` в кольцевую очередь `buf`
    2. Вызов `goready()` на `S` -> планировщик переводит `S` в состояние `runnable`
    *(оптимизация: пропускается этап записи в `buf`, а `S` не нужно отслеживать освобождение места и лочить канал)*
1. Нет данных в кольцевой очереди `buf`...
	1. Есть горутина в очереди на запись `sendq`...
	    (~ канал небуферизован)
	    ... для первой горутины `S` из `sendq`:
	    1. Вызов `recvDirect()` -> прямое перемещение данных из стека `S` в `R`
	    2. Вызов `goready()` на `S` -> планировщик переводит `S` в состояние `runnable`
	2. Нет горутин в очереди на запись `sendq`...
	    ... вызов `gopark()` на `R` -> планировщик переводит `R` в состояние `waiting`
	    `R` + область памяти на чтение перемещаются в очередь `recvq`

У небуферизированных каналов отсутствует буфер, а данные всегда перемещаются напрямую между стеками горутин посредством `sendDirect()` и `recvDirect()`.
## `for ... range`

`for-range` на каналах итерирует канал до тех пор, пока он не закрыт и кольцевая очередь данных не пуста:
```go
for v := range aChannel {
}
```
... можно переписать как:
```go
for {
	v, ok = <-aChannel
	if !ok {
		break
	}
}
```
## `select ... case`

Механизм `select-case` позволяет организовать операции над каналами:
- Выражения в каждом `case` должны быть либо записью в канал, либо чтением из канала.
- Если есть одно и более неблокирующее выражение `case`, они будут вызваны в произвольном порядке
- Если все выражения `case` блокирующие, будет выполнена `default`
- ... если `default` отсутствует, текущая горутина будет добавлена в соответствующие `recvq` и `sendq` всех использованных в `case` каналов

```go
package main

import "fmt"

func main() {
	c := make(chan string, 2)
	trySend := func(v string) {
		select {
		case c <- v:
		default: // go here if c is full.
		}
	}
	tryReceive := func() string {
		select {
		case v := <-c: return v
		default: return "-" // go here if c is empty
		}
	}
	trySend("Hello!") // succeed to send
	trySend("Hi!")    // succeed to send
	// Fail to send, but will not block.
	trySend("Bye!")
	// The following two lines will
	// both succeed to receive.
	fmt.Println(tryReceive()) // Hello!
	fmt.Println(tryReceive()) // Hi!
	// The following line fails to receive.
	fmt.Println(tryReceive()) // -
}
```