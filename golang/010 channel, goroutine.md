# Канал

Для Go справедлив постулат "Не общайтесь разделением памяти. Разделяйте память через общение", - вызовы не делят память, а безопасно передают данные через каналы. Канал работает в семантике FIFO. Операции над каналами являются потокобезопасными для горутин. В контексте блокировки горутин в момент чтения, канал является средством синхронизации.

Канал типизирован. Литерал канала:
- `chan T` - двунаправленный канал
- `chan<- T` - однонаправленный канал только для отправки
- `<-chan T` - однонаправленный канал только для приёма
... где:
- `T` - произвольный тип для значений в канале

`make()` инициализирует канал заданного типа `T` и ёмкости `N`: `make(chan T, N)`.

Канал с нулевой ёмкостью `N` называется небуферизированным.
Канал с ненулевой ёмкостью `N` называется буферизированным.

`cap()` возвращает ёмкость канала, а `len()` позволяет получить текущее число элементов в очереди.

Нулевым значением (неинициализированного) канала является `nil`.

Отправка в канал осуществляется оператором `channel <- value`. Канал не должен быть однонаправленным только для приёма.

Чтение из канала осуществляется оператором `value = <-channel`. Канал не должен быть однонаправленным только для отправки. Доступна форма чтения с признаком того, был ли прочтённый результат отправлен перед закрытием канала: `value, sentBeforeClosed = <-channel`

Вызов `close(channel)` закрывает канал. Канал не должен быть однонаправленным только для приёма.

С момента закрытия канала:
- Читающие горутины читают zero-value без блокировок
- Записывающие горутины паникуют

Граничные свойства операций над каналами:
- Запись и чтение в nil-канал навсегда блокирует горутину
- Закрытие закрытого или nil-канала вызывает панику горутины

| Операция | nil-канал     | Закрытый (non-nil) канал | Не закрытый (non-nil) канал |
| -------- | ------------- | ------------------------ | --------------------------- |
| Закрытие | panic         | panic                    | succeed to close            |
| Запись   | block forever | panic                    | block or succeed to send    |
| Чтение   | block forever | never block              | block or succeed to receive |
# Внутреннее устройство

Структура объекта канала состоит из полей:

1. `lock mutex` - мьютекс для защиты полей
2. `closed uint32` - флаг закрытия канала; тип не `bool`, потому что нет атомика такого типа
3. `elemsize uint16` - размер `elemtype` в байтах
4. `elemtype uint32` - дескриптор типа `T`

5. `buf *buffer` - указатель на кольцевую очередь; кольцевая очередь представляет собой последовательный блок памяти для записи данных канала
6. `dataqsiz uint` - ёмкость кольцевой очереди
7. `qcount uint` - количество элементов в кольцевой очереди
8. `recvx uint` - индекс элемента в кольцевой очереди на чтение; 0 по-умолчанию
9. `sendx uint` - индекс элемента в кольцевой очереди на запись; 0 по-умолчанию

`sendx` и `recvx` обнуляются при достижении ёмкости кольцевой очереди `dataqsiz`

10. `recvq *list` - связный список горутин на чтение
11. `sendq *list` - связный список горутин на запись

`recvq` и `sendq` хранят структуры с полями `G` - дескриптор горутины и `elem` - элемент на отправку, либо ссылка на область памяти на приём.

Последовательность при записи в канал:
1. Захват мьютекса `lock`
2. Попытка записи
	1. Если запись возможна: запись в ячейку `buf[sendx]` копии данных, инкремент `sendx`; (либо) для горутины из `recvq` вызов `sendDirect()` для прямого перемещения элемента из стека горутины-отправителя в стек горутины-получателя; инкремент `qcount`
	2. Если запись невозможна: произойдёт вызов `gopark()`, которая через планировщик переведёт горутину-отправителя в состояние `waiting`; горутина-отправитель + отправляемый элемент перемещаются в очередь `sendq`
3. Отпуск мьютекса `lock`

Последовательность при чтении из канала:
1. Захват мьютекса `lock`
2. Попытка чтения
	1. Если чтение возможно: чтение из ячейки `buf[recvx]`, инкремент `recvx`; для горутины из `sendq` произойдёт вызов `goready()`, которая через планировщик сменит состояние горутины из `sendq` в `runnable`, затем по решению планировщика произойдёт запись элемента `elem` в ячейку `buf[sendx]` с инкрементом `sendx`; декремент `qcount`
	2. Если чтение невозможно: произойдёт вызов `gopark()`, которая через планировщик переведёт горутину-чтеца в состояние `waiting`; горутина-чтец + ячейка для читаемого элемента перемещаются в очередь `recvq`
3. Отпуск мьютекса `lock`

У небуферизированных каналов отсутствует буфер, а данные всегда перемещаются напрямую между стеками горутин посредством `sendDirect()`.

## `select ... case`

В случае `select` чтение каналов неблокирующее, в том числе не производятся вызовы `gopark()`.