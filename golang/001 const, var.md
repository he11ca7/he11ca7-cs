# Константа
Константы вычисляются на этапе компиляции и для них недоступна операция взятия адреса `&`.

Константы подразделяются на:
- именованные и неименованные по признаку места объявления/использования
- типизированные и нетипизированные по признаку объявления типа; тип нетипизированной константы определяется в момент использования исходя из умолчательного типа

Умолчательные типы нетипизированных значений:
- `string` для строк
- `bool` для булевых
- `int` для целочисленных
- `float64` для чисел с плавающей запятой
- `rune` для символов
- `complex128` для констант, содержащих мнимую часть

В месте использования нетипизированных констант происходит неявное преобразование (выведение) результирующего типа на основании их умолчательного типа.

>[!NOTE]
>`true` и `false` -- предопределённые именованные нетипизированные константы

>[!NOTE]
>`nil` -- предопределённая нетипизированная переменная; используется в ссылочных типах в качестве умолчательного значения и не имеет умолчательного типа
## Литералы
Литерал -- неименованная нетипизированная константа.

Для целочисленных типов используются литеральные префиксы:
- `0x...`, `0X...` для шестнадцатеричной записи
- `0...`, `0o...`, `0O...` для восьмеричной записи
- `0b...`, `0B...` для двоичной записи

```go
0xF
0o17
0b1111
15
```

Для типов с плавающей запятой:
- `e` или `E` для записи экспоненциальной части

```go
1.23
.23
1.
1.23e2  // == 123.0
1e-1    // == 0.1
0e+5    // == 0.0
```

`_` может использоваться в записи чисел для улучшения читаемости, но должен быть выделен литеральным префиксом и/или цифровым символом с обеих сторон:
```go
// Валидные примеры
6_9          // == 69
0_33_77_22   // == 0337722
0x_Bad_Face  // == 0xBadFace
0b1011_0111

// Невалидные примеры
_69        // _ не может быть в начале
69_        // _ не может быть в конце
6__9       // с одной из сторон _ не цифра или префикс
0_xBadFace // x не символ восьмеричной записи
```

> [!NOTE]
> Для углубления: hexadecimal floating point literal form, imaginary value literals, rune value literals, string value literals
## Константа (`const`)
`const` объявляет именованную константу. `const` могут быть только примитивные типы: булевый, строковый и числовые.

Возможно объединение объявлений именованных констант, а так же перечисление нескольких типизированных констант одного типа через запятую. Порядок определения констант внутри одного пакета не имеет значения.

Примеры нетипизированных именованных констант:
```go
const π = 3.1416
const (
	No         = !Yes
	Yes        = true
)
```

Примеры типизированных именованных констант:
```go
const (
	A, B int64   = -3, 5
	Y            = float32(2.718) // Тип float32 выведен из объявления
)
```
### iota
Предопределённая нетипизированная именованная константа `iota` используется для генерации констант. `iota` равен 0 в начале каждого объединения объявлений `const` и инкрементируется в каждой последующей строке с объявлениями.
```go
const (
	k = 3 // iota == 0

	m float32 = iota + .5 // m float32 = 1 + .5
	n                     // n float32 = 2 + .5

	p = 9             // iota == 3
	q = iota * 2      // q = 4 * 2
	_                 // _ = 5 * 2
	r                 // r = 6 * 2
	s, t = iota, iota // s, t = 7, 7
	u, v              // u, v = 8, 8
	_, w              // _, w = 9, 9
)
const x = iota // x = 0
const (
	Readable = 1 << iota // == 1
	Writable             // == 2
	Executable           // == 4
)
```

# Переменная
Общая форма объявления переменной `var` состоит из имени, типа и выражения инициализации:
```go
var name type = expression
```

Возможно пропустить либо `type`, либо `= expression`.

Если пропущен `type`, тип определяется из выражения инициализации.

Если пропущено `= expression` устанавливается нулевое значение для данного `type`:
- `false` для булевого типа
- `0` для числовых типов
- `“”` для строкового типа
- `nil` для интерфейсов и ссылочных типов (указателей, срезов, отображений, каналов, функций)

Нулевое значение составного типа складывается из нулевых значений его составляющих.

Возможно перечисление нескольких переменных через запятую, а так же объединение объявлений:
```go
var i, j, k int
var b, f, s = true, 2.3, "four"
var (
	flag, fl   bool       = false
	x          complex128 = -5 + 12i
)
```

Внутри функций возможна короткая форма `:=` объявления с инициализацией. Тип выводится неявно из выражения инициализации.

Короткая форма объявления с инициализацией с перечислением не объявляет повторно переменные, уже объявленные в том же лексическом блоке, а действует для них как присвоение. В короткой форме объявления с инициализацией с перечислением хотя бы одна переменная должна быть объявлена:
```go
in, err := os.Open(infile1)     // Объявлены in и err
out, err := os.Create(outfile)  // Объявлена out, присвоена err
in, err := os.Open(infile2)     // Ошибка компиляции, нет ни одного объявления
```
# Переменная-указатель
Переменные-указатели хранят адреса переменных и объявляются добавлением `*` к типу.

Оператор амперсанд `&` позволяет получить адрес переменной.

Оператор звёздочка `*` позволяет получить переменную из адреса - разыменовать указатель. Разыменование указателя `nil` вызывает `panic`.

```go
x := 1
var p *int = &x // указатель p типа *int указывает на x  
*p = 2          // эквивалент x = 2
```

>[!important]
>Как работает `new(T)`?
# Пустой идентификатор
Пустой идентификатор используется, когда синтаксис требует именовать сущность, тогда как в коде эта сущность не используется.
```go
r, s := true, "bar"
_, _ = r, s // make r and s used
```