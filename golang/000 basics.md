# Ключевые слова и базовые типы

Ключевые слова:
```go
break     default      func    interface  select
case      defer        go      map        struct
chan      else         goto    package    switch
const     fallthrough  if      range      type
continue  for          import  return     var
```

Ключевые слова делятся на категории:
- `var`, `const`, `type`, `func`, `package`, `import` используются для объявлений
- `struct`, `map`, `interface`, `chan` используются как обозначения составных типов
- `return`, `goto`, `if`, `else`, `for`, `range`, `break`, `continue`, `case`, `default`, `fallthrough`, `select`, `switch` ипользуются для управления потоком
- `defet`, `go` так же используются для управления потоком, но в специфических манерах

Базовые типы:
- булевый: `bool`
- целочисленные: `int`, `uint`, `uintptr`, размер которых зависит от реализации
- целочисленные знаковые: `int8`, `int16` `int32` `int64`, хранимые в [дополнительном коде](https://en.wikipedia.org/wiki/Two%27s_complement)
- целочисленные беззнаковые: `uint8`, `uint16`, `uint32`, `uint64`
- с плавающей запятой: `float32`, `float64`, хранимые по стандарту [IEEE 754](https://ru.wikipedia.org/wiki/IEEE_754)
- комплексные: `complex64` и `complex128`, действительная и мнимая части которых хранятся в `float32` и `float64` соответственно
- строковый: `string`

Базовые типы-алиасы:
- байт `uint8`: `byte`
- символ Unicode `int32`: `rune`

# Составные (композитные) типы
> [!WARNING]
> Переработать

Композитные *(composite)* типы:
- Ссылочные типы *(pointer types)*
- Структурные типы *(struct types)*
- Функциональные типы *(function types)*
- Контейнерные типы *(container types)*
	- Массивы *(array types)*
	- Срезы *(slice types)*
	- Карты *(map types)*
- Канальные типы *(channel types)*
- Интерфейсные типы *(interface types)*
# Литералы числовых типов
... также известны как неименованные константы *(unnamed constants)*.

Для булевого типа предопределены именованные константы `true` и `false`.

Для ссылочных типов (указатели, интерфейсы) предопределена константа `nil`.

Для целочисленных типов используются литеральные префиксы:
- `0x...`, `0X...` для шестнадцатеричной *(hexadecimal)* записи
- `0...`, `0o...`, `0O...` для восьмеричной *(octal)* записи
- `0b...`, `0B...` для двоичной *(binary)* записи

```go
0xF
0o17
0b1111
15 // the decimal form
```

Для типов с плавающей запятой:
- `e` или `E` для записи экспоненциальной части

```go
1.23
.23
1.
1.23e2  // == 123.0
1e-1    // == 0.1
0e+5    // == 0.0
```

`_` может использоваться в записи чисел для улучшения читаемости, но должен быть выделен литеральным префиксом и/или цифровым символом в начале и конце:
```go
// Валидные примеры
6_9          // == 69
0_33_77_22   // == 0337722
0x_Bad_Face  // == 0xBadFace
0b1011_0111

// Невалидные примеры
_69        // _ не может быть в начале
69_        // _ не может быть в конце
6__9       // с одной из сторон _ не цифра или префикс
0_xBadFace // x не символ восьмеричной записи
```

> [!NOTE]
> Для углубления: hexadecimal floating point literal form, imaginary value literals, rune value literals, string value literals
# Явное преобразование типов
Для явного *(explicit)* преобразования типов используется форма `T(v)`, при условии, что `v` представимо в типе `T`. Так, например, `int(1.23)` или `uint8(-1)` - некорректные преобразования, приводящие к обрезке или переполнению в рантайме, либо ошибке в компайл-тайме.
# Пустой идентификатор
Пустой идентификатор *(blank identifier)* используется, когда синтаксис требует именовать сущность, тогда как в коде эта сущность не используется.
```go
r, s := true, "bar"
_, _ = r, s // make r and s used
```
# Базовые операции
Двуместные операции в порядке убывания приоритета:
```go
*    /    %    <<  >>  &  &^
+    -    |    ^
==   !=   <    <=  >   >=
&&
||
```
Операторы из первых двух строк имеют сокращённые операторы присваивания, например `+=`.

Унарные операции:
```go
+ - ^ !
```

 Операции инкремента `++` и декремента `--` не возвращают результата, а значит не могут быть использованы как выражения сами по себе.