Массив^[array] - контейнер фиксированной длины, литерал: `[N]T`
Слайс^[slice] - контейнер динамической длины, литерал: `[]T`
... где:
- `T` - произвольный тип для значений, хранимых контейнером
- `N` - длина контейнера, натуральное число; для массива `N` является частью его типа
# Композитный литерал
Композитные литералы^[composite literal] позволяют объявить и инициализировать массив и слайс добавлением `{}` к литералу контейнера.
В композитном литерале массива допустимо указание `...` вместо длины массива - в таком случае длина выводится на этапе компиляции.
В композитном литерале массива и слайса индексы элементов являются опциональными и должны быть константами. В случае отсутствия индекса элемента, выполняется инкремент индекса предыдущего. Индекс первого равен нулю.
Взятие адреса над литералом слайса равноценно инициализации объекта с последующим взятием адреса.

```go
// Эквивалентные литералы массивов
[4]bool{false, true, true, false}
[4]bool{0: false, 1: true, 2: true, 3: false}
[4]bool{1: true, true}
[4]bool{2: true, 1: true}
[...]bool{false, true, true, false}
[...]bool{3: false, 1: true, true}

// Эквивалентные литералы слайсов
[]string{"break", "continue", "fallthrough"}
[]string{0: "break", 1: "continue", 2: "fallthrough"}
[]string{2: "fallthrough", 1: "continue", 0: "break"}
```

Запись вложенных композитных литералов может быть сокращена:
```go
_ = []*[4]byte{
	&[4]byte{'P', 'N', 'G', ' '},
	&[4]byte{'G', 'I', 'F', ' '},
	&[4]byte{'J', 'P', 'E', 'G'},
}

// ... эквивалентно:
_ = []*[4]byte{
	{'P', 'N', 'G', ' '},
	{'G', 'I', 'F', ' '},
	{'J', 'P', 'E', 'G'},
}
```

Пустой список элементов `{}` инициализирует контейнер нулевых значений.
Элементы, хранимые в массиве нулевых значений являются нулевыми значениями его типа.

Неинициализированный слайс равен `nil`. Пустой и неинициализированный слайсы отличаются сериализацией в JSON:
```go
type Response struct {
	Result []int `json:"result"`
}

var s1 []int // nil-slice
b, _ := json.Marshal(&Response{Result: s1}) // {"result":null}

s2 := []int{} // empty slice
b, _ = json.Marshal(&Response{Result: s2}) // {"result":[]}
```

# Доступ и модификация
Элементы массива и слайса доступны по форме `v[k]`, где:
- `v` -- имя переменной;
- `k` -- индекс: `0 <= k < len(v)`, в противном случае паника рантайма; `v != nil`, в противном случае паника рантайма. Константный `k`, не удовлетворяющий условию выше, применённый к массиву, вызовет ошибку компиляции.

Элементы массива и слайса адресуемы:
```go
a := [5]int{2, 3, 5, 7}
s := []bool{false, false}
pa2, ps1 := &a[2], &s[1]
fmt.Println(*pa2, *ps1) // 5 false

a[2], s[1] = 99, true
fmt.Println(*pa2, *ps1) // 99 true

ps0 := &[]string{"Go", "C"}[0]
fmt.Println(*ps0) // Go
```
# Внутреннее устройство
## len(), cap()
Слайс - ссылочный тип, определённый указателем `array` на начало подлежащего массива, длиной `len` и ёмкостью `cap`:
```go
type slice struct {
	array unsafe.Pointer
	len   int
	cap   int
}
```

Элементы массива и слайса хранятся в памяти последовательно.
Встроенные функции `len()` и `cap()` возвращают длину и ёмкость.
Ёмкость слайса больше или равна длине слайса.

Доступ до элемента массива и слайса через ключ имеет сложность O(1): `v[k]`
... где: `v` - переменная слайса, `k` - индекс.
Доступ до элементов nil-слайса и доступ с выходом за границы `len()` вызывают панику.

Память, выделенная между `len()` и `cap()` используется для наполнения слайса без релокации. При переполнении `cap()` слайса происходит релокация: выделяется блок памяти больше нынешнего, выполняется копирование оригинального блока в начало нового.

Слайс, инициализированный другим слайсом, делит со вторым один и тот же подлежащий массив до тех пор, пока не произойдёт релокация:
```go
s0 := []int{7, 8, 9} // [7 8 9]
s1 := s0             // [7 8 9] [7 8 9]
s1[0] = 2            // [2 8 9] [2 8 9]
```

## append()
Вариативная функция `append()` принимает на вход слайс и добавляемые элементы; и возвращает слайс (поскольку возможна релокация):
```go
s0 := []int{2, 3, 5}     // [2 3 5]

// эквивалент append(s1, []int{11, 13}...)
s2 := append(s1, 11, 13) // [2 3 5 11 13]

s3 := append(s0)         // <=> s3 := s0

// эквивалент append(s0, s0[0], s0[1], s0[2])
s4 := append(s0, s0...)  // [2 3 5 2 3 5]

s5 := append([]string(nil), "array", "slice") // ["array" "slice"]
```

## make()
Функция `make()` позволяет инициализировать слайс нулевых значений с заданием длины и ёмкости. Если ёмкость не задана, она равняется длине:
```go
s := make([]int, 3, 5) // [0 0 0] len=3 cap=5
s = make([]int, 2)     // [0 0]   len=2 cap=2
```

## copy()
Для слайсов с общим подлежащим типом доступно копирование посредством `copy()` с заданием слайса-назначения и слайса-источника и возвратом числа скопированных элементов (ра́вно длине меньшего из слайсов):
```go
type Ta []int
type Tb []int

dest := Ta{1, 2, 3}
src := Tb{5, 6, 7, 8, 9}
n := copy(dest, src)     // n=3 dest=[5 6 7]
n = copy(dest[1:], dest) // n=2 dest=[5 5 6]

a := [4]int{}
n = copy(a[:], src)   // n=4 a=[5 6 7 8]
n = copy(a[:], a[2:]) // n=2 a=[7 8 7 8]
```

## clear()
Функция `clear()` сбрасывает элементы массивов и слайсов:
```go
s := []int{1, 2, 3}
clear(s) // [0 0 0]

a := [4]int{5, 6, 7, 8}
clear(a[1:3]) // [5 0 0 8]
```

# for-range
Цикл `for-range` применяется для обхода массивов и слайсов:
```go
for key, value := range container {}

// Ключ и/или значение можно пропустить
for _, value = range container {}
for _, _ = range container {}
for key, _ = range container {}

// ... значение можно вовсе опустить
for key = range container {}
```

Поскольку обход выполняется над копией оригинального `container`, изменение значения `value` массива не приводит к модификации самого моссива; и наоборот для слайса. `key` и `value` так же являются копиями на каждой из итераций.

>[!TODO] ^ проверить экспериментально
# Срез над слайсом
Срез над слайсом (или массивом) `baseSliceVar` позволяет получить подслайc `subSlice` с общим подлежащим массивом с заданием границ:
- нижней длины `low`
- верхней длины `high`
- верхней ёмкости `max`

```go
subSlice := baseSliceVar[low : high]
subSlice := baseSliceVar[low : high : max]
```

Границы должны удовлетворять условию:
```go
0 <= low <= high <= max <= cap(baseSliceVar)
```

Длина `len()` результирующего слайса равна `high - low`.
Ёмкость `cap()` результирующего слайса равна `max - low`.

Если пропущен `min`, он равен `0`.
Если пропущен `high` в двухиндексной форме, он равен `len(baseSliceVar)`.
В двухиндексной форме среза `max` эквивалентен `cap(baseSliceVar)`. В трёхиндексной форме среза `max` не может быть пропущен.

```go
a := [...]int{0, 1, 2, 3, 4, 5, 6}  
s0 := a[:]     // <=> s0 := a[0:7:7]  
s1 := s0[:]    // <=> s1 := s0  
s2 := s1[1:3]  // <=> s2 := a[1:3]  
s3 := s1[3:]   // <=> s3 := s1[3:7]  
s4 := s0[3:5]  // <=> s4 := s0[3:5:7]  
s5 := s4[:2:2] // <=> s5 := s0[3:5:5]  
  
s6 := append(s4, 77)  
s7 := append(s5, 88)  
s8 := append(s7, 66)  
s3[1] = 99  
  
fmt.Println(len(s2), cap(s2), s2) // 2 6 [1 2]  
fmt.Println(len(s3), cap(s3), s3) // 4 4 [3 99 77 6]  
fmt.Println(len(s4), cap(s4), s4) // 2 4 [3 99]  
fmt.Println(len(s5), cap(s5), s5) // 2 2 [3 99]  
fmt.Println(len(s6), cap(s6), s6) // 3 4 [3 99 77]  
fmt.Println(len(s7), cap(s7), s7) // 3 4 [3 4 88]  
fmt.Println(len(s8), cap(s8), s8) // 4 4 [3 4 88 66]
```

Результат в памяти:
![[slice-subslice.png]]
